\begin{flushleft}
    \huge
    \textbf{6. Prototype Code}
    \vspace{0.1cm}

    \large
    Below is the code I created while developing my Prototype. \\
    The 3 Scripts listed in order are: 
    \normalsize
    \begin{enumerate}
        \item main.py
        \item worldClass.py
        \item mathLib.py
    \end{enumerate}

    \noindent\rule{\textwidth}{0.4pt}

    \normalsize
    \begin{enumerate}
        \item main.py
        \begin{lstlisting}[language=Python]
#Imports
import pygame, random, json, os, time
from datetime import datetime
import worldClass, agentClass, mathLib

#Variables
simSize = 64
gridSize = 4
simSeed = 420

#World Functions
def DrawWorld():
    if world.grayscale == False:
    for y in range(0, simSize):
        for x in range(0, simSize):
        colour = world.colourArray[x][y]
        pygame.draw.rect(window, (colour), ((x * gridSize), (y * gridSize), gridSize, gridSize))
    else:
    for y in range(0, simSize):
        for x in range(0, simSize):
        value = world.heightArray[x][y]
        pygame.draw.rect(window, (255 * value, 255 * value, 255 * value), ((x * gridSize), (y * gridSize), gridSize, gridSize))


#World Gen Functions
def RandomWorld():
    SetWorld(random.randint(0, 10000))
def SetWorld(seed):
    world.GenMap(seed)
    DrawWorld()

#Setup
window = pygame.display.set_mode((simSize * gridSize, simSize * gridSize))
pygame.display.set_caption("Procedural Generation")

world = worldClass.WorldMap(simSize)
RandomWorld()

#Main loop
running = True
while running == True:
    for event in pygame.event.get():
    if event.type == pygame.QUIT:
        running = False
    elif event.type == pygame.KEYDOWN:
        if event.key == pygame.K_RETURN:
        RandomWorld()
        elif event.key == pygame.K_F2:
        pygame.image.save(window,"DevelopmentScreenshots\\screenshot{}.png".format(len(next(os.walk("DevelopmentScreenshots"))[2])))

    pygame.display.update()
        \end{lstlisting}

    \item worldClass.py
        \begin{lstlisting}[language=Python]
import random, json

class WorldMap():
    def __init__(self, size):
        self.arraySize = size
        self.heightArray = [[-1 for i in range(size)] for j in range(size)]
        self.colourArray = [[(0, 0, 0) for i in range(size)] for j in range(size)]
        self.typeArray = [[-1 for i in range(size)] for j in range(size)]

        self.inverted = False
        self.grayscale = False
        self.upNeutralDown = 0
        self.averaging = 0
        self.params = []
        self.thresholds = []
        self.LoadParameters("DefaultParameters.json")

    def LoadParameters(self, fname):
        file = open("Presets\\{}".format(fname), "r")
        self.params = json.loads(file.read())
        file.close()
        
        for key in self.params:
            if key == "Inverted":
                if self.params[key] == 1:
                    self.inverted = True
            elif key == "UpNeutralDown":
                self.upNeutralDown = self.params[key]
            elif key == "Averaging":
                self.averaging = self.params[key]
            elif key == "Grayscale":
                if self.params[key] == 1:
                    self.grayscale = True
            else:
                self.thresholds.append((float(key),(self.params[key][0], self.params[key][1], self.params[key][2])))

    def ConvertTypes(self):
        for y in range(0, self.arraySize):
            for x in range(0, self.arraySize):
                for i in range(len(self.thresholds)):
                    value = self.heightArray[x][y]
                    if self.inverted:
                        value = 1 - value
                    if value <= self.thresholds[i][0]:
                        #print(thresholds[i][0])
                        self.colourArray[x][y] = self.thresholds[i][1]
                        self.typeArray[x][y] = i
                        break
            

    def GenMap(self, seed):
        random.seed(seed)
        for y in range(0, self.arraySize):
            for x in range(0, self.arraySize):
                self.heightArray[x][y] = round(random.random(),2)

        for i in range(self.upNeutralDown):
            self.UpNeutralDownGen()
            #print("UNDGen")
        for i in range(self.averaging):
            self.AverageGen()
            #print("averaging")       

        self.ConvertTypes()

    def UpNeutralDownGen(self):
        dupMap = self.heightArray
        for y in range(0, self.arraySize):
            for x in range(0, self.arraySize):
                up = 0
                down = 0
                neutral = 0
                pointArr = []

                if x != 0 and y != 0:
                    pointArr.append(self.heightArray[x - 1][y - 1])
                if x != 0 and y != self.arraySize - 1:
                    pointArr.append(self.heightArray[x - 1][y + 1])
                if x != self.arraySize - 1 and y != self.arraySize - 1:
                    pointArr.append(self.heightArray[x + 1][y + 1])
                if x != self.arraySize - 1 and y != 0:
                    pointArr.append(self.heightArray[x + 1][y - 1])
                if x != 0:
                    pointArr.append(self.heightArray[x - 1][y])
                if y != 0:
                    pointArr.append(self.heightArray[x][y - 1])
                if x != self.arraySize - 1:
                    pointArr.append(self.heightArray[x + 1][y])
                if y != self.arraySize - 1:
                    pointArr.append(self.heightArray[x][y + 1])

                for i in range(len(pointArr)):
                    if pointArr[i] >= self.heightArray[x][y] + 0.1:
                        up += 1
                    elif pointArr[i] <= self.heightArray[x][y] - 0.1:
                        down += 1
                    else:
                        neutral += 1

                if (up > down) and (up > neutral): # Up
                    value = 0.09 * up
                elif (down > up) and (down > neutral): # Down
                    value = -0.08 * down
                else: # Neutral
                    value = 0

                dupMap[x][y] += value
                dupMap[x][y] = self.Clamp(dupMap[x][y], 0, 1)

        self.heightArray = dupMap

    def AverageGen(self):
        dupMap = self.heightArray
        for y in range(0, self.arraySize):
            for x in range(0, self.arraySize):        
                total = 0
                count = 0
                if x != 0 and y != 0:
                    total += self.heightArray[x - 1][y - 1]
                    count += 1
                if x != 0 and y != self.arraySize - 1:
                    total += self.heightArray[x - 1][y + 1]
                    count += 1
                if x != self.arraySize - 1 and y != self.arraySize - 1:
                    total += self.heightArray[x + 1][y + 1]
                    count += 1
                if x != self.arraySize - 1 and y != 0:
                    total += self.heightArray[x + 1][y - 1]
                    count += 1
                if x != 0:
                    total += self.heightArray[x - 1][y]
                    count += 1
                if y != 0:
                    total += self.heightArray[x][y - 1]
                    count += 1
                if x != self.arraySize - 1:
                    total += self.heightArray[x + 1][y]
                    count += 1
                if y != self.arraySize - 1:
                    total += self.heightArray[x][y + 1]
                    count += 1

                dupMap[x][y] = total / count
        self.heightArray = dupMap

    def Clamp(self, val, low, high):
        return low if val < low else high if val > high else val
        \end{lstlisting}
        
    \item mathLib.py
        \begin{lstlisting}[language=Python]
import math, random
class Matrix():
    def __init__ (self, Values, cols = 0, identity = False):
        if type(Values) == list: # Predefined Values
            self.matrixArr = Values
            
        elif identity == True: # Identity Matrix
            if Values != cols:
                raise Exception("Cant create Identity Matrix of different orders")
            else:
                self.matrixArr = [[0 for i in range(cols)] for j in range(Values)]
                for y in range(0, Values):
                    self.matrixArr[y][y] = 1

        elif Values > 0 and cols > 0: # Blank Matrix of size x by y
            self.matrixArr = [[0 for i in range(cols)] for j in range(Values)]

        else: # Error Creating Matrix
            raise Exception("Error Creating Matrix")

    def Val(self):
        return self.matrixArr

    def Dimensions(self):
        return [len(self.matrixArr), len(self.matrixArr[0])] # Rows - Columns

    def ScalarMultiply(self, multiplier):
        for y in range(0, len(self.matrixArr)):
            for x in range(0, len(self.matrixArr[0])):
                self.matrixArr[y][x] = self.matrixArr[y][x] * multiplier

    def SubMatrixList(self, rowList, colList):
        newMat = Matrix(self.Dimensions()[0] - len(rowList),self.Dimensions()[1] - len(colList))
        xoffset = 0
        yoffset = 0
        yRowList = []

        for y in range(0, self.Dimensions()[0]):
            for x in range(0, self.Dimensions()[1]):
                if x in colList and y in rowList:
                    xoffset += 1
                    yoffset += 1
                    continue
                elif x in colList:
                    xoffset += 1
                    continue
                elif y in rowList and y not in yRowList:
                    yoffset += 1
                    yRowList.append(y)
                    continue
                else:
                    newMat.matrixArr[y - yoffset][x - xoffset] = self.matrixArr[y][x]
            xoffset = 0
        return newMat


    def SubMatrixRange(self, y1, y2, x1, x2):
        subMat = Matrix(y2 - y1 + 1, x2 - x1 + 1)
        for y in range(y1, y2 + 1):
            for x in range(x1, x2 + 1):
                subMat.matrixArr[y][x] = self.matrixArr[y][x]
        return subMat

    def RandomVal(self):
        self.matrixArr = [[random.randint(1, 100) for i in range(self.Dimensions()[1])] for j in range(self.Dimensions()[0])]

    def ConvertToVector(self):
        return Vector(self.matrixArr)

    @staticmethod
    def Determinant(m):
        dims = m.Dimensions()
        if dims[1] <= 2:
            det = (m.matrixArr[0][0] * m.matrixArr[1][1]) - (m.matrixArr[0][1] * m.matrixArr[1][0])
            return (det)
        elif dims[1] != 2:
            det = 0
            subtract = False
            tempMat = m.SubMatrixList([0],[])
            for i in range(0, dims[1]):
                subMat = None
                subMat = m.SubMatrixList([0],[i])
                if subtract == False:
                    det += m.matrixArr[0][i] * Matrix.Determinant(subMat)
                    subtract = True
                elif subtract == True:
                    det -= m.matrixArr[0][i] * Matrix.Determinant(subMat)
                    subtract = False
            return det

    def det(m):
        top_length = len(m[0])
        height = top_length - 1
        submats = []

        for i in range(0, top_length):
            submat = [[] for i in range(height)]
            for j in range(0, top_length):
                if i != j:
                    for k in range(height):
                        submat[k].append(m[k+1][j])
            submats.append(submat)
        return submats

    # Static Methods
    @staticmethod
    def MatrixAddSubtract(m1, m2, subtract = False): # Dont know how else i would make this more efficient lol
        m1Dims = m1.Dimensions()
        m2Dims = m2.Dimensions()
        if m1Dims[0] != m2Dims[0]:
            raise Exception("Matrices Row Order does not match")
        elif m1Dims[1] != m2Dims[1]:
            raise Exception("Matrices Column Order does not match")
        elif type(m1) != type():
            raise Exception("Types do not match, Convert Vector to Matrix or vice verse")
        else:
            newMat = Matrix(m1Dims[0], m1Dims[1])
            for y in range(0, m1Dims[0]):
                for x in range(0, m1Dims[1]):
                    if subtract:
                        newMat.matrixArr[y][x] = m1.Val()[y][x] - m2.Val()[y][x]
                    else:
                        newMat.matrixArr[y][x] = m1.Val()[y][x] + m2.Val()[y][x]
            return newMat

    @staticmethod
    def MatrixMultiply(m1, m2): # Not that efficient, needs optimisation
        m1Dims = m1.Dimensions()
        m2Dims = m2.Dimensions()
        if m1Dims[1] != m2Dims[0]:
            raise Exception("Matrices Multiplication Error")
        else:
            if(type(m2) == Vector):
                newMat = Matrix(m1Dims[0], m2Dims[1])
            else:
                newMat = Matrix(m1Dims[0], m2Dims[1])
            for row in range(0, m1Dims[1]):
                subRow = m1.Val()[row][0:m1Dims[1]]
                for col in range(0, m2Dims[1]):
                    subCol = []
                    for i in range(0, m1Dims[0]):
                        print(i)
                        subCol.append(m2.Val()[i][col])
                    total = 0
                    for x in range(0, len(subRow)):
                        total += subRow[x] * subCol[x]
                    newMat.matrixArr[row][col] = total
            return newMat

class Vector(Matrix):
    def __init__(self, val):
        if type(val) == list:
            if len(val[0]) != 1:
                raise Exception("Invalid Vector, use Matrix Instead")
            else:
                self.matrixArr = val
        else:
            self.matrixArr = [[0 for i in range(1)] for j in range(val)]

    def ConvertToMatrix(self):
        return Matrix(self.matrixArr)

    @staticmethod
    def DotProduct(v1,v2):
        if type(v1) != Vector or type(v2) != Vector:
            raise Exception("Wront Types:{},{} passed into Dot Product".format(type(v1),type(v2)))
        else:
            total = 0
            for i in range(v1.Dimensions()[0]):
                total += v1.Val()[i][0] * v2.Val()[i][0]
            return total
        \end{lstlisting}
    \end{enumerate}
\end{flushleft}